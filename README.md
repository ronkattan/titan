# Titan Similar Words Finder by [Ron Kattan](mailto:ron.kattan@gmail.com)

## Getting Started

These instructions will guide you through getting a copy of the project up and running on your local machine for development and testing purposes.

### Prerequisites

Ensure you have Node.js and npm (or pnpm) installed on your system. Check your versions with:

```bash
node --version
npm --version
```

### Installing

To set up your development environment, follow these steps:

1. **Clone the repository**

```bash
git clone https://github.com/ronkattan/titan.git
cd titan
```

2. **Install dependencies**

With npm:

```bash
npm install
```

Or with pnpm:

```bash
pnpm install
```

3. **Build the project**

This compiles the TypeScript source to JavaScript in the `dist` directory and copies necessary resources.
With npm:

```bash
npm run build
```

Or with pnpm:

```bash
pnpm run build
```

4. **Start the server**

Run the following command to start the server:

```bash
npm start
```

Or with pnpm:

```bash
pnpm start
```

The server will default to port 8000. Access the API at `http://localhost:8000`.

## API Endpoints

-   **GET /api/v1/similar?word=<word>**: Finds all dictionary words that are permutations of the specified word.

    -   Example: [http://localhost:8000/api/v1/similar?word=listen](http://localhost:8000/api/v1/similar?word=listen)
    -   Example: [http://localhost:8000/api/v1/similar?word=apple](http://localhost:8000/api/v1/similar?word=apple)

    **Validation:** The word parameter cannot be empty and must consist only of lowercase English letters. Requests not adhering to this pattern will be rejected.

-   **GET /api/v1/stats**: Provides general service statistics, such as total dictionary words, total requests, and average request handling time.

    -   Example: [http://localhost:8000/api/v1/stats](http://localhost:8000/api/v1/stats)

**Note:** Those endpoints are the only authorized routes. Accessing any other endpoints will result in a 404 Not Found response.

## CPU and Memory Optimization

-   **Preprocessing & In-Memory Storage**: At startup, the dictionary is preprocessed and stored efficiently. This reduces the need for heavy computation with each request, saving both CPU time and memory.

-   **Efficient Data Lookup**: The application uses a smart lookup system that allows for quick access to data, significantly speeding up the process of finding similar words.

-   **Simplified Input**: By accepting only lowercase English letters, the app simplifies its processing, leading to quicker response times.

These approaches ensure the application runs smoothly, even under heavy use.

## Handling High Request Volumes

-   **Built on Node.js & Express**: Using Node.js and Express, the application can efficiently manage many requests at once, keeping the service responsive.

-   **Stateless Design**: The server treats each request separately, enhancing its ability to scale and maintain performance under increased loads.

This setup ensures that the service remains fast and reliable, ready to handle numerous requests without a drop in performance.

## Algorithm Explanation Sorting O(n log n) (Deprecated)

~~The service employs a preprocessing step and an efficient retrieval mechanism:~~

~~1. **Preprocessing**: At startup, it reads a dictionary file, creating a key for each word by sorting its letters alphabetically. Words with identical keys are permutations. These are stored in a `Map` for quick access.~~

~~2. **Query Handling**: For a given word, the service:~~
~~- Generates its key.~~
~~- Retrieves all matching words from the `Map`.~~
~~- Excludes the query word from the results and returns the rest.~~

~~This method optimizes for both quick retrieval and efficient memory use, crucial for handling high request volumes.~~

## Algorithm Explanation

The system employs a unique and efficient preprocessing step and retrieval mechanism through a novel key generation approach based on prime numbers:

1. **Preprocessing**: At application startup, the dictionary is preprocessed, with each word assigned a unique key derived from prime numbers. This key is generated by assigning a distinct prime number to each letter (e.g., 'a' = 2, 'b' = 3, 'c' = 5, ...) and calculating the product of these primes for the letters in the word. Given the fundamental theorem of arithmetic, which states that every integer greater than 1 is either a prime number itself or can be uniquely represented as a product of prime numbers (up to the order of the factors), this method ensures that any permutations of the letters will yield the same key.

2. **Query Handling**: When a word is queried:
    - Its prime key is generated using the same prime number assignment.
    - The application efficiently retrieves all words associated with this key from a `Map`, identifying all permutations stored in the dictionary.
    - The queried word is excluded from the results before being returned to the user.

### Choosing `generatePrimeKey`

The decision to use the `generatePrimeKey` function offers an intriguing and practical approach for generating unique keys based on word character composition. This method benefits from the fundamental theorem of arithmetic, ensuring that the character set of each word maps to a unique prime number product. This uniqueness is paramount for identifying permutations, as any permutation of a word's letters will result in the same product.

#### Advantages of Using `generatePrimeKey`

-   **Uniqueness**: The prime number representation guarantees that each unique set of characters maps to a distinct key, making it the optimal choice for identifying permutations.

-   **Efficiency**: Generating a key has a linear time complexity (`O(n)`), making this method highly efficient, even for processing lengthy words.

-   **Simplicity**: Despite its mathematical underpinnings, this method remains conceptually straightforward and easy to implement, as evidenced by the function shared.

This prime number-based method not only ensures swift retrieval through its unique and efficient key generation but also upholds minimal memory overhead, crucial for managing high volumes of requests.

## Benchmark Results

Below is a table showcasing the benchmark results for different key generation methods used in the project. The "time" column represents the execution time, "memoryUsage" shows the Resident Set Size (RSS) memory usage, and "memoryComplexity" indicates the theoretical memory complexity of each method.

| Method             | Time (ms)  | Memory Usage (RSS) | Memory Complexity |
| ------------------ | ---------- | ------------------ | ----------------- |
| Prime Key          | 38.991209  | RSS: 0.02 MB       | O(n)              |
| Frequency Encoding | 208.59825  | RSS: 0.00 MB       | O(n)              |
| Sorting            | 230.211125 | RSS: 13.98 MB      | O(n log n)        |

These results highlight the efficiency and effectiveness of the prime number-based key generation method (`Prime Key`) in terms of both execution time and memory usage, making it a superior choice for our use case.

## Benchmarking

To evaluate the performance and efficiency of the key generation methods, including the prime number-based approach, we have benchmark script. This script compares various key generation methods for their execution time and memory usage, helping to ensure the application's performance is optimized.

To run the benchmarking script:

```bash
npm run benchmark
```

Or with pnpm:

```bash
pnpm benchmark
```

## Handling Simultaneous Requests

The system, built on the Node.js and Express framework, excels at efficiently managing multiple simultaneous requests with minimal impact. Leveraging Node.js's non-blocking I/O model and event-driven architecture (event loop, libuv, Call Stack, and Event Queue), the system adeptly handles simultaneous requests, ensuring fast and reliable responses. **Notably, we are not engaging in heavy asynchronous tasks, such as database queries, which are unlikely in this specific use case. Instead, we're retrieving data from memory, utilizing a prebuilt words map and a query cache to return data for previously made calls swiftly.** This approach ensures that no significant impact occurs, even when handling multiple requests concurrently.

## Testing Simultaneous Requests

To demonstrate the Titan Similar Words Finder's ability to handle multiple simultaneous requests, a TypeScript script has been provided. This script sends six simultaneous requests to the server and logs their responses.

### Running the Test

Ensure your server is running, and then execute the test with the following command:

```bash
npm run test:simultaneous-requests
```

Or with pnpm:

```bash
pnpm test:simultaneous-requests
```

## Built With

-   [Node.js](https://nodejs.org/)
-   [Express](https://expressjs.com/)
-   [TypeScript](https://www.typescriptlang.org/)
